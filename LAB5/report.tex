\documentclass[12pt,a4paper]{article}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{float}
\setlength{\headheight}{15pt}
\usepackage{xeCJK}
\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    breaklines=true,
    showstringspaces=false,
    tabsize=4,
    frame=single,
    rulecolor=\color{black}
}

\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}
\lhead{网络技术与应用实验5}

\title{\textbf{简单路由器程序的设计}}
\author{王泽舜 \\ 学号：2310655}
\date{\today}

\begin{document}

\maketitle

\section{实验要求}

本实验要求设计并实现一个简单的软件路由器程序，使其能与现有路由器产品协同工作。主要功能包括：
\begin{enumerate}
    \item 实现IP数据报的获取、选路和投递等基本功能
    \item 支持路由表的手工插入和删除
    \item 维护ARP缓存表用于IP-MAC地址映射
    \item 记录数据报接收和转发过程的工作日志
    \item 验证IP首部校验和，转发前重新计算校验和
\end{enumerate}

\section{宏观设计框架}

路由器程序采用三层递进式设计：\textbf{设备信息初始化} $\rightarrow$ \textbf{表项维护实现} $\rightarrow$ \textbf{数据转发核心流程}。这种架构确保每一层都有明确的职责边界。

\subsection{整体工作流程}

\begin{figure}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{初始化阶段} & \textbf{运行阶段} & \textbf{转发阶段} \\
        \hline
        枚举网络设备 & 路由表维护 & 接收数据包 \\
        用户选择网卡 & ARP缓存维护 & 校验和验证 \\
        获取本机MAC & 创建转发线程 & 路由表查询 \\
        初始化路由表 & 用户交互循环 & MAC地址查询 \\
                     &              & 修改转发数据包 \\
        \hline
    \end{tabular}
\end{figure}

\section{初始化设计：建立运行环境}

\subsection{设备信息获取}

程序启动时通过Npcap库枚举所有可用网络接口，并存储IP地址和子网掩码。

\begin{lstlisting}[caption={网络设备枚举},label=code:enum]
if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, 
                        &alldevs, errbuf) == -1) {
    printf("Error getting local devices\n");
    return 0;
}

for (d = alldevs; d != NULL; d = d->next) {
    for (a = d->addresses; a != NULL; a = a->next) {
        if (a->addr->sa_family == AF_INET) {
            strcpy(ip[t], inet_ntoa(...));
            strcpy(mask[t], inet_ntoa(...));
        }
    }
}
\end{lstlisting}

用户从枚举列表中选择网卡后，程序使用 \texttt{pcap\_open()} 打开设备。采用混杂模式（\texttt{PCAP\_OPENFLAG\_PROMISCUOUS}）

\subsection{本机MAC地址获取}

由于Windows环境下无法直接获取网卡MAC地址，我们用本机网卡发送一个伪造的ARP请求，本机驱动程序会自动回复，从而获得真实的MAC地址。

\begin{lstlisting}[caption={伪造ARP请求获取本机MAC},label=code:getmac]
ARPFrame_t ARPFrame;
ARPFrame.FrameHeader.DesMAC[i] = 0xff;         // 广播地址
ARPFrame.FrameHeader.FrameType = htons(0x0806);// ARP帧
ARPFrame.SendIP = inet_addr("1.2.3.4");        // 虚构IP
ARPFrame.RecvIP = inet_addr(ip[0]);            // 本机实际IP

pcap_sendpacket(ThisHandle, (u_char*)&ARPFrame, 
                sizeof(ARPFrame_t));

// 等待并捕获ARP应答
while (1) {
    pcap_next_ex(ThisHandle, &pkt_header, &pkt_data);
    IPPacket = (ARPFrame_t*)pkt_data;
    if (ntohs(IPPacket->FrameHeader.FrameType) == 0x0806 &&
        ntohs(IPPacket->Operation) == 0x0002) {
        for(int i = 0; i < 6; i++)
            SrcMac[i] = IPPacket->FrameHeader.SrcMAC[i];
        break;
    }
}
\end{lstlisting}

这个设计巧妙地解决了"先有鸡还是先有蛋"的循环依赖问题：网卡驱动程序会自动识别发往本机IP的ARP请求，并在应用程序之外生成应答，因此无需显式处理。

\subsection{初始化路由表}

路由表在创建时自动添加两个直接连接的网络条目。这些条目对应本机的两个网卡接口，类型标记为0（不可删除）。

\begin{lstlisting}[caption={路由表初始化},label=code:routerinit]
RouterTable::RouterTable() {
    head = new RouterItem;
    tail = new RouterItem;
    head->nextitem = tail;
    num = 0;
    
    for (int i = 0; i < 2; i++) {
        RouterItem* temp = new RouterItem;
        temp->net = inet_addr(ip[i]) & inet_addr(mask[i]);
        temp->mask = inet_addr(mask[i]);
        temp->type = 0;  // 直接连接，不可删除
        this->RouterAdd(temp);
    }
}
\end{lstlisting}

\section{路由表与ARP缓存维护}

\subsection{路由表结构与最长前缀匹配}

路由表采用带哨兵的链表存储，按子网掩码长度从长到短排序。这种设计直接实现了最长前缀匹配：从表头开始遍历，第一个匹配的条目即为最佳匹配。

\begin{lstlisting}[caption={最长前缀匹配},label=code:routerfind]
DWORD RouterTable::RouterFind(DWORD ip) {
    for (RouterItem* t = head->nextitem; t != tail; 
         t = t->nextitem) {
        if ((t->mask & ip) == t->net) {
            return t->nextip;  // 返回下一跳IP
        }
    }
    return -1;  // 无匹配路由
}
\end{lstlisting}

用户可以通过程序的交互菜单手动添加路由表项。新添加的条目按掩码长度插入相应位置，保持有序性。

\begin{lstlisting}[caption={添加路由表项},label=code:routeradd]
else if(op == 2) {
    RouterItem ri;
    char temp[30];
    printf("Enter destination network: ");
    scanf("%s", &temp);
    ri.net = inet_addr(temp);
    
    printf("Enter netmask: ");
    scanf("%s", &temp);
    ri.mask = inet_addr(temp);
    
    printf("Enter next hop address: ");
    scanf("%s", &temp);
    ri.nextip = inet_addr(temp);
    ri.type = 1;  // 用户添加
    RT.RouterAdd(&ri);
}
\end{lstlisting}

\subsection{ARP缓存机制}

ARP缓存是一个全局数组，存储IP地址到MAC地址的映射。转发过程中，如果缓存中没有所需的MAC地址，程序会发送ARP请求并将结果缓存，避免重复查询。

\begin{lstlisting}[caption={ARP缓存查询与插入},label=code:arp]
if (!ArpTable::FindArp(nextip, mac)) {
    // 缓存未命中：发送ARP请求
    ArpTable::InsertArp(nextip, mac);
}

static void InsertArp(DWORD ip, BYTE mac[6]) {
static void InsertArp(DWORD ip, BYTE mac[6]) {
    arptable[num].ip = ip;
    SendARP(ip, arptable[num].mac);  // 发ARP请求
    memcpy(mac, arptable[num].mac, 6);
    num++;
}

static int FindArp(DWORD ip, BYTE mac[6]) {
    for (int i = 0; i < num; i++) {
        if (ip == arptable[i].ip) {
            memcpy(mac, arptable[i].mac, 6);
            return 1;  // 找到
        }
    }
    return 0;  // 未找到
}
\end{lstlisting}

\section{转发线程：数据包处理核心}

\subsection{线程函数架构}

转发线程在后台持续监听网络接口，对每个接收到的报文执行五步处理：

\begin{lstlisting}[caption={转发线程五步处理},label=code:threadflow]
DWORD WINAPI Thread(LPVOID lparam) {
    RouterTable RT = *(RouterTable*)(LPVOID)lparam;
    
    while (1) {
        // 步骤1: 阻塞接收报文
        pcap_pkthdr* pkt_header;
        const u_char* pkt_data;
        while (pcap_next_ex(ThisHandle, &pkt_header, 
                            &pkt_data) == 0);
        
        // 步骤2: MAC目的地址过滤
        FrameHeader_t* header = (FrameHeader_t*)pkt_data;
        if (!Compare(header->DesMAC, SrcMac)) 
            continue;  // 不是发给我的
        
        // 步骤3: 帧类型检查与路由查询
        if (ntohs(header->FrameType) == 0x0800) {
            Data_t* data = (Data_t*)pkt_data;
            DWORD dstip = data->IPHeader.DstIP;
            DWORD IFip = RT.RouterFind(dstip);
            
            if (IFip == -1) continue;  // 无路由
            
            // 步骤4: 校验和验证
            if (!CheckSum(data)) continue;
            
            // 步骤5: ARP查询与转发
            BYTE mac[6];
            if (!ArpTable::FindArp(IFip, mac))
                ArpTable::InsertArp(IFip, mac);
            resend(data, mac);
        }
    }
}
\end{lstlisting}

\subsection{数据包修改与发送}

\texttt{resend()} 函数负责修改报文的MAC地址字段、递减TTL，以及重新计算校验和。

\begin{lstlisting}[caption={数据包转发与修改},label=code:resend]
void resend(ICMP_t data, BYTE desmac[]) {
    Data_t* temp = (Data_t*)&data;
    
    // 交换源目MAC地址
    memcpy(temp->FrameHeader.SrcMAC, 
           temp->FrameHeader.DesMAC, 6);
    memcpy(temp->FrameHeader.DesMAC, desmac, 6);
    
    // TTL递减与检查
    temp->IPHeader.TTL -= 1;
    if (temp->IPHeader.TTL < 0) return;
    
    // 重新计算校验和
    SetCheckSum(temp);
    
    // 发送报文
    pcap_sendpacket(ThisHandle, (const u_char*)temp, 74);
    LT.WritelogIP("转发", temp);
}
\end{lstlisting}

\subsection{IP首部校验和处理}

IP首部校验和采用16位反码求和算法。发送端计算并填充校验和字段，接收端验证；转发时必须重新计算。

\begin{lstlisting}[caption={校验和计算与验证},label=code:checksum]
bool CheckSum(Data_t* temp) {
    unsigned int sum = 0;
    WORD* t = (WORD*)&temp->IPHeader;
    
    for (int i = 0; i < sizeof(IPHeader_t)/2; i++) {
        sum += t[i];
        while (sum >= 0x10000) {
            int s = sum >> 16;
            sum -= 0x10000;
            sum += s;
        }
    }
    return (sum == 65535);
}

void SetCheckSum(Data_t* temp) {
    temp->IPHeader.Checksum = 0;
    unsigned int sum = 0;
    WORD* t = (WORD*)&temp->IPHeader;
    
    for (int i = 0; i < sizeof(IPHeader_t)/2; i++) {
        sum += t[i];
        while (sum >= 0x10000) { 
            int s = sum >> 16;
            sum -= 0x10000;
            sum += s;
        }
    }
    temp->IPHeader.Checksum = ~sum; 
}


\end{lstlisting}

验证原理：正确的IP数据包中，所有16位字（包括校验和）相加的结果应为0xFFFF。

\section{测试结果}

\subsection{网络拓扑}

本实验在虚拟环境中进行。网络拓扑配置如下：

\begin{itemize}
    \item \textbf{终端1}：206.1.1.2/24
    \item \textbf{路由器2（本程序）}：206.1.1.1 和 206.1.2.1
    \item \textbf{路由器3}：206.1.2.2 和 206.1.3.1
    \item \textbf{终端4}：206.1.3.2/24
\end{itemize}

网络拓扑结构 - 终端1和终端4分别连接到路由器2和路由器3，两台路由器通过206.1.2.0/24网段相连

\subsection{程序运行界面}

程序启动后枚举所有可用网络接口，显示设备名、描述、IP地址和子网掩码。用户选择要使用的网卡后，程序自动获取本机MAC地址并初始化路由表。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{picture/vm1ping4.png}
    \caption{终端1 ping 终端4测试}
    \label{fig:vm1ping4}
\end{figure}

\subsection{路由表维护}

初始路由表包含两个直接连接的网络。通过菜单选项2可以添加静态路由，例如添加到206.1.3.0/24网段的路由。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{picture/vm2添加路由.png}
    \caption{在路由器2上添加静态路由表项}
    \label{fig:addroute}
\end{figure}

\subsection{数据转发测试}

\subsubsection{终端1 ping 终端4}

从终端1向终端4发送ICMP请求时，本路由器需要进行转发。转发过程如下：

\begin{enumerate}
    \item 终端1向206.1.3.2发送ICMP请求
    \item 本路由器在206.1.1.1网卡接收报文
    \item 查路由表：206.1.3.0/24 $\rightarrow$ 下一跳206.1.2.2
    \item 查ARP缓存获取206.1.2.2的MAC地址
    \item 修改源MAC为206.1.2.1的MAC，目的MAC为206.1.2.2的MAC
    \item 递减TTL，重新计算校验和
    \item 从206.1.2.1网卡转发出去
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{picture/vm2转发1ping4.png}
    \caption{路由器2转发终端1 ping 终端4的流量}
    \label{fig:forward1to4}
\end{figure}

\subsubsection{终端4 ping 终端1}

反向转发过程中，终端4发往终端1的报文同样需要经过本路由器转发。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{picture/vm2转发4ping1.png}
    \caption{路由器2转发终端4 ping 终端1的流量}
    \label{fig:forward4to1}
\end{figure}

\subsubsection{反向验证}

从终端4的角度验证回程流量的正确接收：

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{picture/vm4ping1.png}
    \caption{终端4接收来自终端1的ICMP应答}
    \label{fig:vm4ping1}
\end{figure}

\section{总结}

本实验成功设计并实现了一个简单的软件路由器，该程序能与真实路由器协同工作，通过验证可以正确转发跨域数据包。在实际应用中，还可以加入超时机制、优先级队列、多线程同步等特性进一步完善。

\end{document}
